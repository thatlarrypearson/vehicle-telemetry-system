# telemetry-obd-log-to-csv/examples/initial_data_analysis.py
"""
Initial Python Pandas data analysis for CSV files generated by obd_log_to_csv,
csv_to_ratio_csv and csv_to_delta_csv.

Requires pandas and matplotlib:
    python3.8 -m pip install pandas matplotlib seaborn
"""
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from argparse import ArgumentParser
import configparser
from sys import stdout, stderr
from io import TextIOWrapper
from pathlib import Path

DATE_COLUMNS = ['iso_ts_pre', 'iso_ts_post', 'duration', ]

PLOT_DPI = 300
PLOT_STYLE = 'seaborn-poster'

def command_line_options()->dict:
    parser = ArgumentParser(prog="initial_data_analysis",
                        description="""Initial Python Pandas data analysis for
                        CSV files generated by obd_log_to_csv, csv_to_ratio_csv
                        or csv_to_delta_csv.
                        """)

    parser.add_argument(
        "--verbose",
        help="Turn verbose output on. Default is off.",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--output_directory",
        help="Output file path.",
        default="initial_data_analysis",
    )

    parser.add_argument(
        "--numeric_columns",
        help="Limit analysis to these columns otherwise use all columns.  Format: col1,col2,col3,...,coln",
        default=None,
    )

    parser.add_argument(
        "files",
        help="path for obd_log_to_csv, csv_to_ratio_csv or csv_to_delta_csv generated files.",
        default=None,
        nargs="+",
    )

    parser.add_argument(
        "--forward_fill",
        help="Fill NaN values with the closest non-NaN value from above",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--backward_fill",
        help="Fill NaN values with the closest non-NaN value from below",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--general_info",
        help="Output the General Information section",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--general_stats",
        help="Output the General Statistics section",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--correlations",
        help="Output the Correlations section",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--covariances",
        help="Output the Covariances section",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--line_graphs",
        help="Output the Line Graphs section",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--normalized_line_graphs",
        help="Output the Normalized Line Graphs section",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--histograms",
        help="Output the Histogram Graphs section",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--scatter_plots",
        help="Output the Scatter Plots section",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--3d_scatter_plots",
        help="Output the 3D scatter Plots section",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--kernel_density",
        help="Output the 2D kernel density estimation (KDE) section",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--plots_to_screen",
        help="Output Plots/Graphs to the screen",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--no_plots_to_files",
        help="Don't save any Plots/Graphs to disk",
        default=False,
        action='store_true'
    )
 
    return vars(parser.parse_args())

def ready_directory(file_path:str, verbose=False):
    """Like 'mkdir --parents' but first strips off the file name"""
    if verbose:
        print(f"\t\t{file_path} parent  {Path(file_path).parent}", file=stderr)
    Path(file_path).parent.mkdir(parents=True, exist_ok=True)

def read_csv(file_path, verbose=False):
    """Read CSV files into a Pandas dataframe."""
    return pd.read_csv(file_path, parse_dates=DATE_COLUMNS)

def parse_numeric_columns(columns:str)->list:
    """parse a comma separated list (no spaces) of columns and return the columns as a list."""
    return columns.split(',')

def get_numeric_columns(all_columns)->list:
    """Get a list of numeric collumns"""
    # get all columns except iso_ts_pre, iso_ts_post and duration into text column names
    return [column for column in all_columns if column not in DATE_COLUMNS]

def open_text_file_for_write(output_directory:str, file_name:str, verbose=False) -> TextIOWrapper:
    """Open a text file for writing"""
    if verbose:
        print(f"opening text file for write: {output_directory}/{file_name}", file=stderr)
    return open(f"{output_directory}/{file_name}", 'w', encoding='utf-8')

def print_general_info(df, output_directory, verbose=False):
    """Print general information about a Pandas dataframe"""
    fd = open_text_file_for_write(output_directory, "general_info.txt", verbose=verbose)
    if verbose:
        print(df.dtypes, file=stderr)
        print(df.shape, file=stderr)
        print(df.info(), file=stderr)
        print(df.describe(), file=stderr)
    print(df.dtypes, file=fd)
    print(df.shape, file=fd)
    print(df.info(), file=fd)
    print(df.describe(), file=fd)
    # df['iso_ts_pre'].head()
    # df['iso_ts_pre'].tail()
    # df.median()
    # df.mode()
    fd.close()


def print_general_stats(df, output_directory:str, verbose=False):
    """
    General Statistics
    """
    fd = open_text_file_for_write(output_directory, "general_stats.txt", verbose=verbose)
    for column in df.columns:
        vmax = (df[df[column].notnull()])[column].max()
        vmin = (df[df[column].notnull()])[column].min()
        vmean = (df[df[column].notnull()])[column].mean()
        vstd = (df[df[column].notnull()])[column].std()
        not_null_rows = (df[df[column].notnull()])[column].shape[0]
        null_rows = df.shape[0] - not_null_rows
        if verbose:
            print(f"{column}", file=stderr)
            print(f"\tmax: {vmax}", file=stderr)
            print(f"\tmin: {vmin}", file=stderr)
            print(f"\tmean: {vmean}", file=stderr)
            print(f"\tstd: {vstd}", file=stderr)
            print(f"\tnot null rows: {not_null_rows}", file=stderr)
            print(f"\tnull rows: {null_rows}", file=stderr)
        print(f"{column}", file=fd)
        print(f"\tmax: {vmax}", file=fd)
        print(f"\tmin: {vmin}", file=fd)
        print(f"\tmean: {vmean}", file=fd)
        print(f"\tstd: {vstd}", file=fd)
        print(f"\tnot null rows: {not_null_rows}", file=fd)
        print(f"\tnull rows: {null_rows}", file=fd)
    fd.close()

def print_correlations(df, output_directory:str, verbose=False):
    """
    Correlation
    """
    fd = open_text_file_for_write(output_directory, "correlations.txt", verbose=verbose)
    corr = df.corr()
    with pd.option_context('display.max_rows', None,
                        'display.max_columns', None,
                        'display.precision', 6,
                        ):
        result = corr[corr < 1].unstack().transpose().sort_values(ascending=False).drop_duplicates()
        if verbose:
            print("Correlation", file=stderr)
            print(result, file=stderr)

        print(result, file=fd)
    fd.close()

def print_covariances(df, output_directory:str, verbose=False):
    """
    Covariance
    """
    fd = open_text_file_for_write(output_directory, "covariances.txt", verbose=verbose)
    cov = df.cov()
    with pd.option_context('display.max_rows', None,
                        'display.max_columns', None,
                        'display.precision', 6,
                        ):
        result = cov.unstack().transpose().sort_values(ascending=False).drop_duplicates()
        if verbose:
            print("Covariance", file=stderr)
            print(result, file=stderr)

        print(result, file=fd)
        fd.close()

def print_line_graphs(df, numeric_columns:list, plots_to_screen:bool, plots_to_files:bool, output_directory:str, verbose=False):
    """
    Line Graphs
    create line graph for each numeric column
    """
    if verbose:
        print("printing line graphs", file=stderr)
    for col in numeric_columns:
        if verbose:
            print(f"\tgraphing {col}", file=stderr)
        plt.style.use(PLOT_STYLE)
        ((df[df[col].notnull()])[col]).plot(kind='line', title=f"Line Graph Of {col}",
                                            y=col, ylabel=col,
                                            x='iso_ts_pre', xlabel='iso_ts_pre',
                                            legend=True)
        if plots_to_screen:
            plt.show()
        if plots_to_files:
            plot_file_path = f"{output_directory}/line/{col}.png"
            ready_directory(plot_file_path, verbose=verbose)
            plt.savefig(plot_file_path,
                dpi=PLOT_DPI, facecolor='w', edgecolor='w', orientation='landscape',
                format=None, transparent=True, bbox_inches=None, pad_inches=0.2, metadata=None)
        plt.close("all")

def print_normalized_line_graphs(df, numeric_columns:list, plots_to_screen:bool, plots_to_files:bool, output_directory:str, verbose=False):
    """
    Normalized Line Graphs
    create line graph for each numeric column
    Normalize column values using min/max method
    """
    def minmax_norm(tdf):
        return (tdf - tdf.min()) / ( tdf.max() - tdf.min())

    if verbose:
        print("printing normalized line graphs", file=stderr)
    for col in numeric_columns:
        if verbose:
            print(f"\tgraphing {col}", file=stderr)
        plt.style.use(PLOT_STYLE)
        df_norm = minmax_norm(df[df[col].notnull()])
        (df_norm[col]).plot(
            kind='line', title=f"Normalized Line Graph of {col}",
            y=col, ylabel=col,
            x='iso_ts_pre', xlabel='iso_ts_pre',
            legend=True)

        if plots_to_screen:
            plt.show()
        if plots_to_files:
            plot_file_path = f"{output_directory}/line-normalized/{col}.png"
            ready_directory(plot_file_path, verbose=verbose)
            plt.savefig(plot_file_path,
                dpi=PLOT_DPI, facecolor='w', edgecolor='w', orientation='landscape',
                format=None, transparent=True, bbox_inches=None, pad_inches=0.2, metadata=None)
        plt.close("all")

def print_histograms(df, numeric_columns:list, plots_to_screen:bool, plots_to_files:bool, output_directory:str, verbose=False):
    """
    Histograms
    create histogram for each numeric column
    """
    if verbose:
        print("printing normalized line graphs", file=stderr)
    for col in numeric_columns:
        if verbose:
            print(f"\tgraphing {col}", file=stderr)
        plt.style.use(PLOT_STYLE)
        df_not_null = (df[df[col].notnull()])
        df_not_null[col].plot(
            kind='hist', title=f"Histogram: {col}",
            xlabel=col, bins=20, legend=True)

        if plots_to_screen:
            plt.show()
        if plots_to_files:
            plot_file_path = f"{output_directory}/histogram/{col}.png"
            ready_directory(plot_file_path, verbose=verbose)
            plt.savefig(plot_file_path,
                dpi=PLOT_DPI, facecolor='w', edgecolor='w', orientation='landscape',
                format=None, transparent=True, bbox_inches=None, pad_inches=0.2, metadata=None)
        plt.close("all")

def print_scatter_plots(df, numeric_columns:list, plots_to_screen:bool, plots_to_files:bool, output_directory:str, verbose=False):
    """
    2D Scatter Plots
    create scatter plot for each pair (x,y) of columns where x and y are not the same column name
    """
    if verbose:
        print("printing 2D scatter plots", file=stderr)
    for xcol in numeric_columns:
        for ycol in numeric_columns:
            if xcol == ycol:
                continue
            if verbose:
                print(f"\tgraphing {xcol}, {ycol}", file=stderr)
            plt.style.use(PLOT_STYLE)
            ((df[df[xcol].notnull()])).plot(
                kind='scatter', title=f"Scatter Plot of {ycol} and {xcol}",
                y=ycol, ylabel=ycol, x=xcol, xlabel=xcol, legend=True)

            if plots_to_screen:
                plt.show()
            if plots_to_files:
                plot_file_path = f"{output_directory}/scatter2/{ycol}-{xcol}.png"
                ready_directory(plot_file_path, verbose=verbose)
                plt.savefig(plot_file_path,
                    dpi=PLOT_DPI, facecolor='w', edgecolor='w', orientation='landscape',
                    format=None, transparent=True, bbox_inches=None, pad_inches=0.2, metadata=None)
            plt.close("all")

def print_3d_scatter_plots(df, numeric_columns:list, plots_to_screen:bool, plots_to_files:bool, output_directory:str, verbose=False):
    """
    2D Scatter Plots with 3rd D Shading
    create scatter plot for each triplet (x,y, z) of columns where x, y and z are distinct column names
    """
    def xyz_not_unique(x:list)->bool:
        return len(x) > len(set(x))

    if verbose:
        print("printing 3D scatter plots", file=stderr)

    for xcol in numeric_columns:
        for ycol in numeric_columns:
            for zcol in numeric_columns:
                if xyz_not_unique([xcol,ycol,zcol]):
                    continue
                if verbose:
                    print(f"\tgraphing {xcol}, {ycol}, {zcol}", file=stderr)
                plt.style.use(PLOT_STYLE)
                ((df[df[xcol].notnull()])).plot(kind='scatter', title=f"Scatter Plot of {xcol}, {ycol} and {zcol}",
                            x=xcol, xlabel=xcol, y=ycol, ylabel=ycol, c=zcol, cmap='gray_r', legend=True)
                
                if plots_to_screen:
                    plt.show()
                if plots_to_files:
                    plot_file_path = f"{output_directory}/scatter3/{xcol}-{ycol}-{zcol}.png"
                    ready_directory(plot_file_path, verbose=verbose)
                    plt.savefig(plot_file_path,
                                dpi=PLOT_DPI, facecolor='w', edgecolor='w', orientation='landscape',
                                format=None, transparent=True, bbox_inches=None, pad_inches=0.2, metadata=None)
                plt.close("all")

def print_kernel_density(df, numeric_columns:list, plots_to_screen:bool, plots_to_files:bool, output_directory: str, verbose=False):
    """
    Seaborn Kernel Density Plot
    create kernel density plot for each pair (x,y) of columns where x and y are not the same column name
    """
    if verbose:
        print("printing kernel density plot", file=stderr)
    for xcol in numeric_columns:
        for ycol in numeric_columns:
            if xcol == ycol:
                continue
            if verbose:
                print(f"\tgraphing {xcol}, {ycol}", file=stderr)
            plt.style.use(PLOT_STYLE)

            sns.jointplot(kind='kde',
                y=ycol, x=xcol, legend=True,
                shade=True, cbar=True,
                data=df)

            if plots_to_screen:
                plt.show()
            if plots_to_files:
                plot_file_path = f"{output_directory}/kernel_density/{ycol}-{xcol}.png"
                ready_directory(plot_file_path, verbose=verbose)
                plt.savefig(plot_file_path,
                    dpi=PLOT_DPI, facecolor='w', edgecolor='w', orientation='landscape',
                    format=None, transparent=True, bbox_inches=None, pad_inches=0.2, metadata=None)
            plt.close("all")


def main():

    args = command_line_options()

    csv_input_files = args['files']
    verbose = args['verbose']
    output_directory = args['output_directory']
    numeric_columns = args['numeric_columns']

    forward_fill = args['forward_fill']
    backward_fill = args['backward_fill']

    general_stats = args['general_stats']
    general_info = args['general_info']
    correlations = args['correlations']
    covariances = args['covariances']

    line_graphs = args['line_graphs']
    normalized_line_graphs = args['normalized_line_graphs']
    histograms = args['histograms']
    scatter_plots = args['scatter_plots']
    scatter_plots_3d = args['3d_scatter_plots']
    kernel_density =args['kernel_density']
    plots_to_screen = args['plots_to_screen']
    plots_to_files = not args['no_plots_to_files']

    pd.set_option("display.max.columns", None)

    if verbose:
        print(f"csv_input_files: {csv_input_files}", file=stderr)
        print(f"output_directory: {output_directory}", file=stderr)

        print(f"forward_fill: {forward_fill}", file=stderr)
        print(f"backward_fill: {backward_fill}", file=stderr)

        print(f"general_info: {general_info}", file=stderr)
        print(f"general_stats: {general_stats}", file=stderr)
        print(f"correlations: {correlations}", file=stderr)
        print(f"covariances: {covariances}", file=stderr)

        print(f"line_graphs: {line_graphs}", file=stderr)
        print(f"normalized_line_graphs: {normalized_line_graphs}", file=stderr)
        print(f"histograms: {histograms}", file=stderr)
        print(f"scatter_plots: {scatter_plots}", file=stderr)
        print(f"scatter_plots_3d: {scatter_plots_3d}", file=stderr)
        print(f"kernel_density: {kernel_density}", file=stderr)

        print(f"plots_to_screen: {plots_to_screen}", file=stderr)
        print(f"plots_to_files: {plots_to_files}", file=stderr)

    # load all files on command line into a single dataframe
    # this should fail if the columns aren't an exact match
    df = pd.concat(map(read_csv, csv_input_files))

    if numeric_columns:
        numeric_columns = parse_numeric_columns(numeric_columns)
    else:
        # get all numeric columns
        numeric_columns = get_numeric_columns(df.columns)

    if verbose:
        print(f"numeric_columns: {numeric_columns}", file=stderr)

    # make output directory
    Path(output_directory).mkdir(parents=True, exist_ok=True)

    if forward_fill:
        if verbose:
            print("Filling Forward")
        df.fillna(method="ffill", inplace=True)
    if backward_fill:
        if verbose:
            print("Filling Backward")
        df.fillna(method="bfill", inplace=True)

    if general_info:
        print_general_info(df, output_directory, verbose=verbose)
    if general_stats:
        print_general_stats(df, output_directory, verbose=verbose)
    if correlations:
        print_correlations(df, output_directory, verbose=verbose)
    if covariances:
        print_covariances(df, output_directory, verbose=verbose)

    if line_graphs:
        print_line_graphs(df, numeric_columns, plots_to_screen, plots_to_files, output_directory, verbose=verbose)
    if normalized_line_graphs:
        print_normalized_line_graphs(df, numeric_columns, plots_to_screen, plots_to_files, output_directory, verbose=verbose)
    if histograms:
        print_histograms(df, numeric_columns, plots_to_screen, plots_to_files, output_directory, verbose=verbose)
    if scatter_plots:
        print_scatter_plots(df, numeric_columns, plots_to_screen, plots_to_files, output_directory, verbose=verbose)
    if scatter_plots_3d:
        print_3d_scatter_plots(df, numeric_columns, plots_to_screen, plots_to_files, output_directory, verbose=verbose)
    if kernel_density:
        print_kernel_density(df, numeric_columns, plots_to_screen, plots_to_files, output_directory, verbose=verbose)

    plt.close("all")


if __name__ == '__main__':
    main()

