# CSV To Ration CSV
# telemetry-obd-log-to-csv/ogd_log_to_csv/csv_to_ratio_csv.py
from sys import stdout, stderr
import csv
from argparse import ArgumentParser
from io import TextIOWrapper
from copy import deepcopy
from datetime import timedelta
from dateutil import parser


def command_line_options()->dict:
    parser = ArgumentParser(prog="obd_log_to_csv",
                description="""Telemetry CSV To Ratio CSV
                                generates values indicating the ratio of pairs of
                                identified columns.  All original columns pass through
                                unmolested.  The ratio columns are added columns.
                                """)

    parser.add_argument(
        "--input_csv_file",
        help="""
        CSV file generated by obd_log_to_csv.obd_log_to_csv that includes the header.
        That is, each column in the file has a valid text column name in the first row.
        """,
    )

    parser.add_argument(
        "--ratio",
        help="""
        Comma separated list of command pairs to be used in making ratios.  e.g. the ratio
        for SPEED/RPM would be represented by "SPEED/RPM" with the resulting ratio being
        SPEED divided by RPM. Null/NaN values ignored.  The divisor can't be zero.
        A comma separated command list might look like
        "SPEED/RPM,FUEL_RATE/RELATIVE_ACCELERATOR_POSITION,MAF/ENGINE_LOAD".
        In the CSV file, the column name will be "COMMAND_NAME1/COMMAND_NAME2".
        e.g. "SPEED/RPM".
        """,
    )

    parser.add_argument(
        "--output_csv_file",
        help="""CSV output file.
                File can be either a full or relative path name.
                If the file already exists, it will be overwritten.
                Do not make the input and output file the same.
                Bad things will happen.  Defaults to terminal output (stdout).
                """,
        default="stdout",
    )

    parser.add_argument(
        "--verbose",
        help="Turn verbose output on. Default is off.",
        default=False,
        action='store_true'
    )

    return vars(parser.parse_args())

def column_pair_parser(column_pair):
    # ratio_columns = (args['ratio']).split(sep=',') if args['ratio'] else []
    dividend_and_divisor = column_pair.split(sep='/')
    return dividend_and_divisor[0], dividend_and_divisor[1]

def ratio_divisor_to_dividend_mapper(ratio_column_pairs)->dict:
    divisors = {}
    for column_pair in ratio_column_pairs:
        dividend, divisor = column_pair_parser(column_pair)
        if divisor not in divisors:
            divisors[divisor] = []
        divisors[divisor].append(dividend)
    
    return divisors

def ratio(input_csv_file, output_csv_file, ratio_column_pairs, verbose=False):

    reader = csv.DictReader(input_csv_file)
    field_names = reader.fieldnames

    # check to make sure ratio column pairs map into the input CSV file columns
    for column_pair in ratio_column_pairs:
        dividend, divisor = column_pair_parser(column_pair)
        if dividend not in field_names:
            raise ValueError(f"ratio {column_pair} column '{dividend}' missing from CSV input file")
        if divisor not in field_names:
            raise ValueError(f"ratio {column_pair} column '{divisor}' missing from CSV input file")

    all_field_names = field_names + ratio_column_pairs

    writer = csv.DictWriter(output_csv_file, fieldnames=all_field_names)
    writer.writeheader()

    ratio_map = ratio_divisor_to_dividend_mapper(ratio_column_pairs)

    for in_row in reader:
        if verbose:
            print(f"in_row: {in_row}", file=stderr)

        # the original row passes through unmolested
        out_row = deepcopy(in_row)

        # delta columns are added and set to None
        for divisor in ratio_map:
            for dividend in ratio_map[divisor]:
                out_row[f"{dividend}/'{divisor}"] = None
                if in_row[divisor] is None:
                    continue
                if in_row[dividend] is None:
                    continue
                if not float(in_row[divisor]):
                    continue
                out_row[f"{dividend}/'{divisor}"] = float(in_row[dividend]) / float(in_row[divisor])

        if verbose:
            print(f"out_row: {out_row}", file=stderr)

        writer.writerow(out_row)

def main():
    args = command_line_options()

    input_csv_file_name = args['input_csv_file']
    output_csv_file_name = args['output_csv_file']
    verbose = args['verbose']

    ratio_column_pairs = (args['ratio']).split(sep=',') if args['ratio'] else []

    if verbose:
        print(f"verbose: {args['verbose']}", file=stderr)
        print(f"input csv file: {input_csv_file_name}", file=stderr)
        print(f"output csv file: {output_csv_file_name}", file=stderr)
        print(f"ratio_columns: {ratio_column_pairs}", file=stderr)

    if output_csv_file_name != "stdout":
        with open(output_csv_file_name, "w") as output_csv_file:
            with open(input_csv_file_name, "r") as input_csv_file:
                ratio(input_csv_file, output_csv_file, ratio_column_pairs, verbose=verbose)
    else:
        with open(input_csv_file_name, "r") as input_csv_file:
            ratio(input_csv_file, stdout, ratio_column_pairs, verbose=verbose)

if __name__ == "__main__":
    main()
